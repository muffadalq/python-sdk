#!/usr/bin/env python
"""

dhutil:    Datera Host Utility

Usage:
    dhutil
        --basename <string>
        --template <string>
        --size <string> (GB)
        --count <int>
        --numreplicas <int>
        --cleanall
        --showall
        --mkfs
        --mpmap
        --dirprefix <string>
        --chown <string>
        --fstype <string>
        --createfio
        --snappol  <RETCOUNT> <SNAPINTERVAL>
        --volperf  <TOTAL_IOPS_MAX> <TOTAL_BANDWIDTH_MAX>
        --clone <APP_INSTANCE_NAME> 
        --tenant <TENANT_NAME>

    'basename' corresponds to the app_instance
    'size' is interpreted as number of GB.
    'count' is the number of app_instances to create
    'numreplicas' is the number of replicas to create
    'template' must refer to an existing template
    'cleanall' applies only to a given 'basename'
    'showall' takes no other args/options
    'mkfs' will create ext4 file systems on the volumes created
    'mpmap' will show the hostside multipath volume mapping
    'dirprefix' specifies a mount point prefix for the volume mount
    'chown' specifies chown:chgrp for the mount point
    'fstype currently xfs (default) or ext4
    'createfio' creates sample fio files for each volume
    'snappol' specifies snapshot retention count and interval
    'volperf' volume-level total max iops and bandwidth
    'clone' clone a specified application instance
    'tenant' uses the specified tenant name for create application instances

"""
import sys
import os
import subprocess
import argparse
import re
import client
from client import get_client
import server
import utilities

CLONE_AI_LIST = []
API_VER = "2.0"


def usage():
    print """
Usage:
    dhutil
        --basename <string>
        --template <string>
        --size <string> (GB)
        --count <int>
        --numreplicas <int>
        --cleanall
        --showall
        --mkfs
        --mpmap
        --dirprefix <string>
        --chown <string>
        --fstype <string>
        --createfio
        --snappol  <RETCOUNT> <SNAPINTERVAL>
        --volperf  <TOTAL_IOPS_MAX> <TOTAL_BANDWIDTH_MAX>
        --clone <APP_INSTANCE_NAME> 
        --tenant <TENANT_NAME>

    'basename' corresponds to the app_instance
    'size' is interpreted as number of GB.
    'count' is the number of app_instances to create
    'numreplicas' is the number of replicas to create
    'template' must refer to an existing template
    'cleanall' applies only to a given 'basename'
    'showall' takes no other args/options
    'mkfs' will create ext4 file systems on the volumes created
    'mpmap' will show the hostside multipath volume mapping
    'dirprefix' specifies a mount point prefix for the volume mount
    'chown' specifies chown:chgrp for the mount point
    'fstype currently xfs (default) or ext4
    'createfio' creates sample fio files for each volume
    'snappol' specifies snapshot retention count and interval(15min, 1hour, 1day, 1month, 1year)
    'volperf' volume-level total max iops and bandwidth(KBps)
    'clone' clones a specified application instance
    'tenant' uses the specified tenant name for create application instances


"""

    exit(1)

def clean_all(c, s):
    c.unmount()
    c.target_logout_and_node_cleanup(s)
    s.delete_ai()
    s.delete_initiator()
    s.delete_tenants()

def chk_args(args):

    # the only options allowed without basename
    if not args.basename and not args.showall and not args.mpmap:
        print "ERROR: most options require basename"
        usage()

    # need at least one of these
    if not args.basename and not args.showall and not args.mpmap:
        print "ERROR:  Need atleast 'basename', 'showall' or 'mpmap'"
        usage()

    # options required if basename
    if args.basename and not (args.template or args.count or
                              args.cleanall or args.mpmap or args.mkfs or args.clone):
        print "ERROR: Missing required arguments for 'basename'"
        usage()

    # options not allowed with cleanall
    if args.cleanall and (args.size or args.count or args.showall or
                          args.mkfs or args.mpmap or args.dirprefix or
                          args.chown or args.template or
                          args.fstype or args.numreplicas):
        print "ERROR: 'cleanall' include extraneous options"
        usage()

    # option combinations required
    if args.count and not (args.size or args.template):
        print "ERROR: 'count' requires 'size' or 'template'"
        usage()

    if args.template and not args.count:
        print "ERROR: 'template' requires 'count'"
        usage()

    if args.fstype and not args.mkfs:
        print "ERROR: 'fstype' requires 'mkfs'"
        usage()

    # options not allowed together
    if (args.size or args.numreplicas) and args.template:
        print "ERROR: 'size' and 'numreplicas' not allowed with 'template'"
        usage()

    # options with specific required values
    if args.fstype and args.fstype not in ['ext4', 'xfs']:
        print "ERROR: Only 'xfs' and 'ext4' are allowed for fstype"
        usage()
    
    if args.snappol:
       if args.snappol[0].isdigit() == False:
          print "ERROR: RETCOUNT must be an integer"
          usage()
       if args.snappol[1] not in ('15min','1hour','1day','1week','1month','1year'):
          print "ERROR: INTERVAL must be '15min' or '1hour' or '1day' or '1week' or '1month' or '1year'"
          usage()

    if args.tenant == "root":
        print "ERROR: root is not an allowed value for the tenant argument"
        usage()

def iscsiadm_chk():
    try:
        subprocess.check_output(["iscsiadm", "--version"])
    except OSError as e:
        print 
        print "iscsiadm not available."
        print "Please install :"
        print "      RH/CentOS: 'yum install iscsi-initiator-utils'"
        print "      Ubuntu:    'apt-get install open-iscsi'"
        print
        sys.exit(1)

def mpath_chk():
    try:
        subprocess.check_output(["multipath", "-v0", ])
    except OSError as e:
        print 
        print "multipath not available."
        print "Please install :"
        print "      RH/CentOS: 'yum install device-mapper-multipath'"
        print "      Ubuntu:    'apt-get install multipath-tools'"
        print
        sys.exit(1)

def lsscsi_chk():
    try:
        subprocess.check_output(["lsscsi", "-t", ])
    except OSError as e:
        print 
        print "lsscsi not available."
        print "Please install :"
        print "      RH/CentOS: 'yum install lsscsi'"
        print "      Ubuntu:    'apt-get install lsscsi'"
        print
        sys.exit(1)

def dbck():
    # Check for docker bug: https://github.com/docker/docker/issues/7101"
    try:
        subprocess.check_output(
            "grep sysfs /proc/mounts | grep ro", shell=True)
        try:
            subprocess.call("mount -o rw,remount sysfs /sys")
            sys.exit(0)
        except Exception as e:
            print "Encountered https://github.com/docker/docker/issues/7101"
            print "and cannot remount /sys.  Need to be root?"
            sys.exit(1)
    except Exception as e:
        # sysfs is not mounted 'ro'
        pass

def main():

    if (len(sys.argv) < 2):
        usage()

    dbck()
    iscsiadm_chk()
    mpath_chk()
    lsscsi_chk()
    parser = argparse.ArgumentParser(description='dhutil')
    parser.add_argument('--basename', action="store", dest="basename")
    parser.add_argument('--template', action="store", dest="template")
    parser.add_argument('--createfio', action="store_true")
    parser.add_argument('--size', action="store", dest="size")
    parser.add_argument('--count', action="store", dest='count', type=int)
    parser.add_argument('--numreplicas', action="store", dest='numreplicas',
                        type=int)
    parser.add_argument('--cleanall', action="store_true")
    parser.add_argument('--showall', action="store_true")
    parser.add_argument('--mkfs', action="store_true")
    parser.add_argument('--mpmap', action="store_true")
    parser.add_argument('--dirprefix', action="store", dest='dirprefix')
    parser.add_argument('--chown', action="store", dest='chown')
    parser.add_argument('--fstype', action="store", dest='fstype')
    parser.add_argument('--snappol', action="store", dest="snappol", nargs=2, 
                       metavar=('RETCOUNT','INTERVAL'),help='volume-level snapshot retention count and interval')
    parser.add_argument('--volperf', action="store", dest="volperf", nargs=2, 
                       metavar=('TOTAL_IOPS_MAX','TOTAL_BANDWIDTH_MAX[KBps]'), type=int, 
                       help='volume-level iops and bandwidth policies')
    parser.add_argument('--clone', action="store_true",
                       help='clones app instances that start with basename')
    parser.add_argument('--tenant', action="store",
                       help='creates tenant with given name. If exists, uses that tenant')
    args = parser.parse_args()

    if args.basename and len(args.basename) < 3:
        print "Validation Error:  %s : must be at least 3 chars" % basename
        sys.exit(-1)

    # Make sure args make sense
    chk_args(args)

    c = client.Client(args)
    s = server.Server(args)
    u = utilities.Utilities(args)
    api = s.api

    if args.cleanall:
        c = get_client(args)
        clean_all(c,s)
        sys.exit(0)

    if args.showall:
        s.show_all()
        if args.mpmap:
            u.print_server_client_map(s, c)
        sys.exit(0)

    if args.mpmap and not args.count:
        u.print_server_client_map(s, c)
        sys.exit(0)

    iscsi_initiator = c.get_initiator_name()
    ii = s.create_initiator(iscsi_initiator)

    #
    # Semantics:  If a template exists, create args.count instances
    #             from that template.
    #             If a template does not exist, create args.count instances
    #             Assumes 1:1:1 ratio of AppInstance:StorageInstance:Volume
    # TODO:       Allow non-singleton configurations

    # Make sure template exists
    if args.template:
        if s.chk_template():
            #if api.system.get()['sw_version'].startswith(API_VER):
            tenant = s.create_tenant()
            ailist = s.create_ai_from_template(ii, tenant)
            # Login to the storage
            for ai in ailist:
	        for si in ai.storage_instances.list(tenant=tenant):
		    s.op_state_poller(si)
		    print si['name'] + " is  online"
		    c.target_login(si)
            c._run_cmd("lsscsi -t")
        else:
            print args.template, " : does not exist!"
            sys.exit(-1)
    elif args.count:
        #if not api.system.get()['sw_version'].startswith(API_VER):
        # Create N app_instances, storage_instance, and add initiator
        tenant = s.create_tenant()
        ailist = s.create_ai(tenant)
        silist = s.create_si(ii, tenant, ailist)
        vlist = s.create_vol(tenant, silist)
        for ai in ailist:
            for si in ai.storage_instances.list(tenant=tenant):
                s.op_state_poller(si)
                print si['name'] + " is online"
                c.target_login(si)

    if args.mkfs:
        mntmap = u.create_fs_mntmap(s,c)
        c.mp_mkfs(mntmap)

    if args.createfio:
        mntmap = u.create_fs_mntmap(s,c)
        c.create_fio_files(mntmap)
    
    # This logic needs to be re-written. Currently clones should not be supported. That's a project for another time. 
    if args.clone:
        cmd="mount |grep " + args.basename
        global CLONE_AI_LIST 
        CLONE_AI_LIST = s.clone_an_app_instance()
        
        #discover cloned volumes and login
        for ai in api.app_instances.list():
            if ai['name'].startswith(args.basename) and ai["name"].endswith("clone"):
                si = ai.storage_instances.list()[0]
                c.target_login(si)

        c._run_cmd("lsscsi -t")
        mntmap = u.create_fs_mntmap(s,c)
        #mntmap = mpmap(api, args,tenant)
        
        try:
           output = subprocess.check_output(cmd, shell=True)
           if args.basename in output:
              for item in mntmap:
                 if "xfs" in output:
                    cmd = "mkdir -p /{}; mount -o nouuid {} /{}".format(item[1],item[0],item[1])
                 else:
                    cmd = "mkdir -p /{}; mount {} /{}".format(item[1],item[0],item[1])
                 print "mounting " + item[1]
                 os.system(cmd)
                 if item[2].chown:
                    os.system("chown -R {} /{}".format(item[2].chown, item[1]))
        except subprocess.CalledProcessError as e:
           print str(e) + "\n" + basename + " are block devices without filesystems. Cannot mount clone."
           pass
        
if __name__ == '__main__':
    main()
