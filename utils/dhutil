#!/usr/bin/env python
"""

dhutil:    Datera Host Utility

Usage:
    dhutil
        --basename <string>
        --template <string>
        --size <string> (GB)
        --count <int>
        --numreplicas <int>
        --cleanall
        --showall
        --mkfs
        --mpmap
        --dirprefix <string>
        --chown <string>
        --fstype <string>
        --createfio
        --snappol  <RETCOUNT> <SNAPINTERVAL>
        --volperf  <TOTAL_IOPS_MAX> <TOTAL_BANDWIDTH_MAX>
        --clone <APP_INSTANCE_NAME> 
        --tenant <TENANT_NAME>

    'basename' corresponds to the app_instance
    'size' is interpreted as number of GB.
    'count' is the number of app_instances to create
    'numreplicas' is the number of replicas to create
    'template' must refer to an existing template
    'cleanall' applies only to a given 'basename'
    'showall' takes no other args/options
    'mkfs' will create ext4 file systems on the volumes created
    'mpmap' will show the hostside multipath volume mapping
    'dirprefix' specifies a mount point prefix for the volume mount
    'chown' specifies chown:chgrp for the mount point
    'fstype currently xfs (default) or ext4
    'createfio' creates sample fio files for each volume
    'snappol' specifies snapshot retention count and interval
    'volperf' volume-level total max iops and bandwidth
    'clone' clone a specified application instance
    'tenant' uses the specified tenant name for create application instances

"""
import sys
import os
import subprocess
import platform
import time
import argparse
import linecache
import re
import multiprocessing as mp
from dfs_sdk import DateraApi
from dfs_sdk import DateraApi21

SLEEP = 10
NUMREPLICAS = 3
DISK_BY_PATH = "/dev/disk/by-path"
#DISK_BY_UUID = "/dev/disk/by-uuid"
SYS_BLOCK = "/sys/block"
CLONE_AI_LIST = []
API_VER = "2.1"


def usage():
    print """
Usage:
    dhutil
        --basename <string>
        --template <string>
        --size <string> (GB)
        --count <int>
        --numreplicas <int>
        --cleanall
        --showall
        --mkfs
        --mpmap
        --dirprefix <string>
        --chown <string>
        --fstype <string>
        --createfio
        --snappol  <RETCOUNT> <SNAPINTERVAL>
        --volperf  <TOTAL_IOPS_MAX> <TOTAL_BANDWIDTH_MAX>
        --clone <APP_INSTANCE_NAME> 
        --tenant <TENANT_NAME>

    'basename' corresponds to the app_instance
    'size' is interpreted as number of GB.
    'count' is the number of app_instances to create
    'numreplicas' is the number of replicas to create
    'template' must refer to an existing template
    'cleanall' applies only to a given 'basename'
    'showall' takes no other args/options
    'mkfs' will create ext4 file systems on the volumes created
    'mpmap' will show the hostside multipath volume mapping
    'dirprefix' specifies a mount point prefix for the volume mount
    'chown' specifies chown:chgrp for the mount point
    'fstype currently xfs (default) or ext4
    'createfio' creates sample fio files for each volume
    'snappol' specifies snapshot retention count and interval(15min, 1hour, 1day, 1month, 1year)
    'volperf' volume-level total max iops and bandwidth(KBps)
    'clone' clones a specified application instance
    'tenant' uses the specified tenant name for create application instances


"""

    exit(1)

#
# Create Volume within a storage instance.
# Takes storage_instance as input parameter
#


def vol_create(si, name, args, api):
    if args.numreplicas:
        numreplicas = args.numreplicas
    else:
        numreplicas = NUMREPLICAS
    tenant = ''
    if args.tenant:
       tenant = "/root/" + args.tenant
    #if api.system.get()['sw_version'] > API_VER:
    if api.system.get()['sw_version'].startswith(API_VER):
       vol = si.volumes.create(name=name, size=int(args.size),replica_count=int(numreplicas), tenant=tenant)
       if args.snappol:
          vol.snapshot_policies.create(name=name, retention_count=int(args.snappol[0]),interval=args.snappol[1], tenant=tenant)
       if args.volperf:
          vol.performance_policy.create(total_iops_max = int(args.volperf[0]),total_bandwidth_max = int(args.volperf[1]), tenant=tenant)
    else:
       vol = si.volumes.create(name=name,size=int(args.size),replica_count=int(numreplicas))
       if args.snappol:
          vol.snapshot_policies.create(name=name,retention_count=int(args.snappol[0]),interval=args.snappol[1])
       if args.volperf:
          vol.performance_policy.create(total_iops_max = int(args.volperf[0]),total_bandwidth_max = int(args.volperf[1]))

    return vol['uuid']


def initiator_create(api, name, id):
    iis = api.initiators.list()
    for i in iis:
        if i['id'] == id:
            print "Initiator: (%s) %s,  already exists" % (i['name'], id)
            return i
    print "Creating Initiator: (%s) %s" % (name, id)
    return api.initiators.create(name=name, id=id)


def PrintException():
    exc_type, exc_obj, tb = sys.exc_info()
    f = tb.tb_frame
    lineno = tb.tb_lineno
    filename = f.f_code.co_filename
    linecache.checkcache(filename)
    line = linecache.getline(filename, lineno, f.f_globals)
    print 'EXCEPTION IN ({}, LINE {} "{}"): {}'.format(
        filename, lineno, line.strip(), exc_obj)


def run_cmd(cmd):
    print cmd
    os.system(cmd)


def target_logout_and_node_cleanup(api, node, basename):
    for ai in api.app_instances.list():
        for si in ai.storage_instances.list():
            if ai['name'].startswith(basename):
                #print si['access']['ips']
                if 'iqn' in si['access']:
                    run_cmd("iscsiadm -m node -u -T %s" % si['access']['iqn'])
                    run_cmd("iscsiadm -m node -T %s --op=delete" % si['access']['iqn'])
                for ip in si['access']['ips']:
                    run_cmd("iscsiadm -m discoverydb -t st -p %s:3260 --op=delete" % ip)

    #Ubuntu and debian
    if platform.dist()[0] == 'Ubuntu':
           run_cmd("iscsiadm -m session --rescan")
           run_cmd("service multipath-tools reload")
    #rhel, centos, sles
    else:
       run_cmd("iscsiadm -m session --rescan")
       run_cmd("service multipathd reload")

def target_login(node, si, initiator, sleep=SLEEP):
    # Wait a bit ...
    if sleep != 0:
        print "Wait %s for storage to come online " % sleep
        time.sleep(sleep)
    iqn = si['access']['iqn']
    print "IQN: " + iqn
    for ip in si['access']['ips']:
        print "IP ADDRS = ", ip
        cmd = "iscsiadm -m node -T {} --portal {} --op=new".format(iqn, ip)
        cmd = cmd + " > /dev/null 2>&1"
        run_cmd(cmd)
        cmd = "iscsiadm -m node -T {} --portal {} -l"
        run_cmd(cmd.format(iqn, ip))

def clean_all(api, target, args):
    # Check API Version
    if api.system.get()['sw_version'].startswith(API_VER):
       if args.tenant:
          tenantname = "/root/" + args.tenant
       else:
          tenantname = ''
       # Deleting app instances
       for app_instance in api.app_instances.list(tenant=tenantname):
          if not app_instance["name"].startswith(target):
              continue
          print "Delete app instance " + app_instance['name']
          app_instance.set(admin_state="offline", force=True, tenant=tenantname)
          app_instance.delete(tenant=tenantname)
     
       # Deleting initators
       for initiator in api.initiators.list():
          if not initiator["name"].startswith(target):
             continue
          print "Delete initiator " + initiator['name']
          initiator.delete()

       # Deleting tenants
       if tenantname != '':
          for tenant in api.tenants.list():
             if tenant['path'] == '/tenants/root':
                continue
             if not api.app_instances.list():
                tenant.delete(tenant=tenantname)
                print "Deleted tenant " + tenant['name']
             else:
                print "Tenant is not empty and hence was not deleted"

    else:
       for app_instance in api.app_instances.list():
           if not app_instance["name"].startswith(target):
             continue
           print "Delete app instance " + app_instance['name']
           app_instance.set(admin_state="offline", force=True)
           app_instance.delete()

       for initiator in api.initiators.list():
          if not initiator["name"].startswith(target):
              continue
          print "Delete initiator " + initiator['name']
          initiator.delete()


def sn_to_hostname(api, sn):
    #uuid = sn.split("/")[2]
    if api.system.get()['sw_version'].startswith(API_VER):
       uuid = sn['path'].split("/")[2]
    else:
       uuid = sn.split("/")[2]
    sn = api.storage_nodes.get(uuid)
    return sn['name']

def si_to_hostname(api, si):
    sn_name = 'undef'
    for sn in si['active_storage_nodes']:
       if api.system.get()['sw_version'].startswith(API_VER):
          uuid = sn['path'].split("/")[2]
       else:
          uuid = sn.split("/")[2]
       sn = api.storage_nodes.get(uuid)
       sn_name = 'undef'
       sn_name = sn['name']
    #todo, this only returns the last active server in the list 
    return sn_name

def show_all(api):
    for at in api.app_templates.list():
        print "App_Template: " + at['name']
    if api.system.get()['sw_version'].startswith(API_VER):
       for tenant in api.tenants.list():
           print "Tenant: " + tenant['name']
           if tenant["name"] != "root" :
                tenant = "/root/" + tenant["name"]
           else:
                tenant = "/" + tenant["name"]
           for ai in api.app_instances.list(tenant=tenant):
               print "  App_instance: " + ai['name']
               print "    admin_state: ", ai['admin_state']
               for si in ai.storage_instances.list(tenant=tenant):
                   print "    -Storage_instance: " + si['name']
                   for i in si.acl_policy.initiators.list(tenant=tenant):
                       print "        +Initiators: %s  (%s)" % (i['id'], i['name'])
                   if 'iqn' in si['access']:
                       print "        +IQN: " + si['access']['iqn']
                   for ip in si['access']['ips']:
                       print "        +ACCESS IP: " + ip
                   for sn in si['active_storage_nodes']:
                       print "        +ACTIVE_STORAGE_NODES: " + sn_to_hostname(api, sn)
                   for v in si.volumes.list(tenant=tenant):
                       print "        =Volume: {},   Size : {},   UUID : {} ".format(v['name'], v['size'], v['uuid'])
    else:
       for ai in api.app_instances.list():
           print "App_instance: " + ai['name']
           print "    admin_state: ", ai['admin_state']
           for si in ai.storage_instances.list():
               print "    -Storage_instance: " + si['name']
               for i in si.acl_policy.initiators.list():
                   print "        +Initiators: %s  (%s)" % (i['id'], i['name'])
               if 'iqn' in si['access']:
                   print "        +IQN: " + si['access']['iqn']
               for ip in si['access']['ips']:
                   print "        +ACCESS IP: " + ip
               for sn in si['active_storage_nodes']:
                   print "        +ACTIVE_STORAGE_NODES: " + sn_to_hostname(api, sn)
               for v in si.volumes.list():
                   print "        =Volume: {},   Size : {},   UUID : {} ".format(v['name'], v['size'], v['uuid'])


# [0] = dmpath, [1] = mntpoint, [2] = cmdargs
def mkfs(args):
    if args[2].fstype == "ext4":
        cmd = "mkfs.ext4 -E lazy_itable_init=1 {} ; mkdir -p /{}; mount {} /{}".format(args[0], args[1], args[0], args[1])
    else:
        cmd = "mkfs.xfs {} ; mkdir -p /{}; mount {} /{}".format(args[0], args[1], args[0], args[1])
    print cmd
    os.system(cmd)
    if args[2].chown:
        os.system("chown -R {} /{}".format(args[2].chown, args[1]))

def uuid_to_dm(args,uuid):
    for f in os.listdir(DISK_BY_UUID):
        if uuid in f:
           return os.path.basename(os.readlink(DISK_BY_UUID + "/" + uuid))

def iqn_to_sd(args,iqn):		 
    for f in os.listdir(DISK_BY_PATH):
        if iqn in f:
           return os.path.basename(os.readlink(DISK_BY_PATH + "/" + f))

def sd_to_dm(sd):
    for f in os.listdir(SYS_BLOCK):
        t = SYS_BLOCK + "/" + f + "/" + "slaves" + "/" + sd
        if os.path.islink(t):
           return f

def dm_to_mapper(dm):
    fname = "{}/{}/dm/name".format(SYS_BLOCK, dm)
    with open(fname, 'r') as f:
       mapper = f.read().strip()
    f.closed
    return mapper

def mapper_to_dmpath(mapper):
    return "/dev/mapper/" + mapper

def map_def(api, args, basename):
     map = {}
     if args.clone:
        assert CLONE_AI_LIST, "clone list is EMPTY"
        ai_list = CLONE_AI_LIST
     else:
        if api.system.get()['sw_version'].startswith(API_VER):
           for t in api.tenants.list():
              t = t.reload()
              if t["name"] != "root" :
                 tenant = "/root/" + t["name"]
              else:
                 tenant = "/" + t["name"]
              for ai in api.app_instances.list(tenant=tenant):
                 for si in ai['storage_instances']:
                    for v in si['volumes']:
                       id = v['uuid']
                       if not basename or basename in ai['name']:
                          map[id] = {'tname': t['name'], 'aname': ai['name'], 'sname': si['name'],'vname': v['name'], 'id': id, 'nodename': si_to_hostname(api,si) }
                          if 'iqn' in si['access']:
                              map[id]['iqn'] = si['access']['iqn']
        else:
           for ai in api.app_instances.list():
              ai = ai.reload()
              for si in ai['storage_instances'].itervalues():
                 for v in si['volumes'].itervalues():
                    id = v['uuid']
                    if not basename or basename in ai['name']:
                       map[id] = {'aname': ai['name'], 'sname': si['name'],'vname': v['name'], 'id': id, 'nodename': si_to_hostname(api,si) }
                       if 'iqn' in si['access']:
                           map[id]['iqn'] = si['access']['iqn']
     return map
  

def mpmap(api, args, tenant):
    dist = platform.dist()[0]
    #map = {}
    mntmap = []
    basename = args.basename

    map = map_def(api, args, basename)
    
    for m in map:
        if args.volperf:
            print "Sleeping 3s for target to be discovered"
            time.sleep(3)
        sd = iqn_to_sd(args,map[m]['iqn'])
        if sd:
            dm = sd_to_dm(sd)
            #dm = uuid_to_dm(args,map[m]['id'])
            if not dm:
                print "No DM for sd: ", sd + ". Please make sure that multipath service is running. Then cleanall and retry"
                sys.exit(-1)
            mapper = dm_to_mapper(dm)
            if not mapper:
                print "No mapper entry for dm: ", dm + ". Please make sure that multipath service is running. Then cleanall and retry"
                sys.exit(-1)
            dmpath = mapper_to_dmpath(mapper)

            if api.system.get()['sw_version'].startswith(API_VER):
               print "HOST-DM: " + dm + \
                     "   DATERA: " + map[m]['tname'] + "/" + map[m]['aname'] + "/" + map[m]['sname']  + "/" + map[m]['vname'] + \
                     "   IQN: " + map[m]['iqn'] + \
                     "   MAPPER: /dev/mapper/" + mapper + \
                     "   NODE:" + map[m]['nodename']
            else:
               print "HOST-DM: " + dm + \
                     "   DATERA: " + map[m]['aname'] + "/" + map[m]['sname']  + "/" + map[m]['vname'] + \
                     "   IQN: " + map[m]['iqn'] + \
                     "   MAPPER: /dev/mapper/" + mapper + \
                     "   NODE:" + map[m]['nodename']

            if args.mkfs or args.clone:
                # ASSUME "singleton" 1:1:1 (app_inst:storage_inst:vol)
                mntpoint = map[m]['aname'] + "-" + map[m]['vname']
                if args.dirprefix:
                    mntpoint = args.dirprefix + "/" + mntpoint
                mntmap.append([dmpath, mntpoint, args])

    if args.mkfs or args.clone:
#        pool = mp.Pool()
#        list(pool.imap_unordered(mkfs, mntmap))
        return mntmap
    else:
       return map

def create_fio_template():
    with open('fiotemplate.fio','w') as f:
       lines = ["[global]","randrepeat=0","ioengine=libaio","iodepth=16","direct=1","numjobs=4","runtime=3600","group_reporting","time_based"]
       for line in lines:
          f.write(line + '\n')

def create_fio_files(api,args,tenant):

    fio = {args.basename + '_randread.fio':{'rw':'randread', 'blocksize':'4k'},
           args.basename + '_seqread.fio':{'rw':'read', 'blocksize':'1m'},
           args.basename + '_randwrite.fio':{'rw':'randwrite', 'blocksize':'4k'},
           args.basename + '_seqwrite.fio':{'rw':'write', 'blocksize':'1m'},
           args.basename + '_randreadwrite.fio':{'rw':'randrw', 'rwmixread': '70', 'blocksize':'4k'}
          }

    create_fio_template()
    mntmap = mpmap(api,args,tenant)

    for key,item in fio.items():
       with open('fiotemplate.fio', 'r') as f:
          with open(key, 'w') as key:
             for line in f:
                key.write(line)
             for param in item:
                key.write(param + "=" + item[param] + '\n')
             if args.mkfs:
                for index in range(len(mntmap)):
                   #key.write("[" + str(key).split()[2].strip(',') + "]" + '\n')
                   key.write("[fiofile]" + '\n')
                   key.write("directory=/" + mntmap[index][1] + '\n')
                   key.write("size=500M" + '\n')
             else:
                 for id in mntmap:
                    #key.write("[" + str(key).split()[2].strip(',') + "]" + '\n')
                    key.write("[fiofile]" + '\n')
                    sd = iqn_to_sd(args, mntmap[id]['iqn'])
                    if sd:
                       #dm = uuid_to_dm(args, mntmap[id]['id'])
                       dm = sd_to_dm(sd)
                       key.write("filename=/dev/" + dm + '\n')
                       key.write("size=500M" + '\n')

def get_volume_id_and_path(api, app_instance):
    volume_map = {}
    ai = api.app_instances.get(app_instance['name'])
    for si in ai['storage_instances'].keys():
       volume_map[si] = {}
       for vol in ai['storage_instances'][si]['volumes'].keys():
          volume_map[si][vol] = {}
          volume_map[si][vol]['path'] = ai['storage_instances'][si]['volumes'][vol]['path']
          if 'acl_policy' in ai['storage_instances'][si]:
             volume_map[si][vol]['acl_policy'] = ai['storage_instances'][si]['acl_policy']['initiators']
          if 'performance_policy' in ai['storage_instances'][si]['volumes'][vol]:
             volume_map[si][vol]['performance_policy'] = ai['storage_instances'][si]['volumes'][vol]['performance_policy']
          if 'snapshot_policies' in ai['storage_instances'][si]['volumes'][vol]:
             volume_map[si][vol]['snapshot_policy'] = ai['storage_instances'][si]['volumes'][vol]['snapshot_policies']
    return volume_map

def copy_snapshot_policy(new_app_instance, volume_map, si, vol):
    for snapid in volume_map[si][vol]['snapshot_policy']:
        name = volume_map[si][vol]['snapshot_policy'][snapid]['name']
        ret_count = volume_map[si][vol]['snapshot_policy'][snapid]['retention_count']
        start_time = volume_map[si][vol]['snapshot_policy'][snapid]['start_time']
        interval =  volume_map[si][vol]['snapshot_policy'][snapid]['interval']
        new_app_instance.storage_instances.get(si).volumes.get(vol).snapshot_policies.create(name=name, retention_count=ret_count, start_time=start_time, interval=interval)

def clone_an_app_instance(api,args):
    clone_ai_list = []
    if api.system.get()['sw_version'].startswith(API_VER):
       print "cloning via dhutil is not yet supported in " + api.system.get()['sw_version']
       sys.exit(-1)
    else:
        for app_instance in api.app_instances.list():
            if app_instance["name"].startswith(args.basename):
               try:
                    # get volume id
                    volume_map = get_volume_id_and_path(api, app_instance)
                    for si in volume_map.keys():
                       for vol in volume_map[si].keys():
                          # clone app Intance with volume id as the new name
                          new_app_instance = api.app_instances.create(name=app_instance['name'] + "_clone", clone_src=volume_map[si][vol]['path'])
                          # copy acl policies
                          if 'acl_policy' in volume_map[si][vol]:
                             acl_policy = api.app_instances.get(app_instance['name']).storage_instances.get(si).acl_policy.get()
                             new_app_instance.storage_instances.get(si).acl_policy.set(initiators=[str(volume_map[si][vol]['acl_policy'][0])])
                             time.sleep(2)
                             if new_app_instance.reload()['storage_instances'][si]['op_state'] != "available":
                                 print "error copying acl_policies"
                                 sys.exit(1)
                             #add initiator groups
                          # copy performance policies
                          if 'performance_policy' in volume_map[si][vol]:
                             performance_policy = api.app_instances.get(app_instance['name']).storage_instances.get(si).volumes.get(vol).performance_policy.list()[0]
                             new_app_instance.storage_instances.get(si).volumes.get(vol).performance_policy.create(total_iops_max=performance_policy['total_iops_max'],
                             total_bandwidth_max=performance_policy['total_bandwidth_max'],
                             read_iops_max=performance_policy['read_iops_max'],
                             read_bandwidth_max=performance_policy['read_bandwidth_max'],
                             write_iops_max=performance_policy['write_iops_max'],
                             write_bandwidth_max=performance_policy['write_bandwidth_max'])
                             time.sleep(2)
                             if new_app_instance.reload()['storage_instances'][si]['op_state'] != "available":
                                 print "error copying performance_policies"
                                 sys.exit(1)
                          # copy snapshot policies
                          if 'snapshot_policy' in volume_map[si][vol]:
                             copy_snapshot_policy(new_app_instance, volume_map, si, vol)
                             time.sleep(2)
                             if new_app_instance.reload()['storage_instances'][si]['op_state'] != "available":
                                 print "error copying snapshot_policies"
                                 sys.exit(1)
                          print "cloned " + app_instance['name'] + " to " + new_app_instance['name']
                          state = api.app_instances.get(new_app_instance["name"]).set(admin_state="online")
                          print "setting admin state of " + new_app_instance['name'] + " to " + state["admin_state"]
                          clone_ai_list.append(new_app_instance)
               except KeyError:
                    msg = "appInstance: [{}] doesn't exist".format(app_instance['name'])
                    print msg
                    continue
    return clone_ai_list
   
def chktempl(api, templ):
    for at in api.app_templates.list():
        if at['name'] == templ:
            return True
    return False


def unmount(name):
    cmd = "mount |grep %s | awk '{print $3}'" % name
    for l in os.popen(cmd).readlines():
        line = l.rstrip()
        if line == "/":
           print "skipping unmount of /"
           return None
        p = os.path.basename(line)
        print p
        print line
        run_cmd("umount %s" % line)
        run_cmd("rm -rf %s" % line)
     # cleanup fio files
    run_cmd("rm -rf " + name + "*.fio")


def nocreds():
    print
    print "Credentials needed of form 'user:password:IPAddr'"
    print "supplied in DTSCREDS environment variable"
    print
    sys.exit(-1)


def chk_args(args):

    # the only options allowed without basename
    if not args.basename and not args.showall and not args.mpmap:
        print "ERROR: most options require basename"
        usage()

    # need at least one of these
    if not args.basename and not args.showall and not args.mpmap:
        print "ERROR:  Need atleast 'basename', 'showall' or 'mpmap'"
        usage()

    # options required if basename
    if args.basename and not (args.template or args.count or
                              args.cleanall or args.mpmap or args.mkfs or args.clone):
        print "ERROR: Missing required arguments for 'basename'"
        usage()

    # options not allowed with cleanall
    if args.cleanall and (args.size or args.count or args.showall or
                          args.mkfs or args.mpmap or args.dirprefix or
                          args.chown or args.template or
                          args.fstype or args.numreplicas):
        print "ERROR: 'cleanall' include extraneous options"
        usage()

    # option combinations required
    if args.count and not (args.size or args.template):
        print "ERROR: 'count' requires 'size' or 'template'"
        usage()

    if args.template and not args.count:
        print "ERROR: 'template' requires 'count'"
        usage()

    if args.fstype and not args.mkfs:
        print "ERROR: 'fstype' requires 'mkfs'"
        usage()

    # options not allowed together
    if (args.size or args.numreplicas) and args.template:
        print "ERROR: 'size' and 'numreplicas' not allowed with 'template'"
        usage()

    # options with specific required values
    if args.fstype and args.fstype not in ['ext4', 'xfs']:
        print "ERROR: Only 'xfs' and 'ext4' are allowed for fstype"
        usage()
    
    if args.snappol:
       if args.snappol[0].isdigit() == False:
          print "ERROR: RETCOUNT must be an integer"
          usage()
       if args.snappol[1] not in ('15min','1hour','1day','1week','1month','1year'):
          print "ERROR: INTERVAL must be '15min' or '1hour' or '1day' or '1week' or '1month' or '1year'"
          usage()

    if args.tenant == "root":
        print "ERROR: root is not an allowed value for the tenant argument"
        usage()
    

def iscsiadm_chk():
    try:
        subprocess.check_output(["iscsiadm", "--version"])
    except OSError as e:
        print 
        print "iscsiadm not available."
        print "Please install :"
        print "      RH/CentOS: 'yum install iscsi-initiator-utils'"
        print "      Ubuntu:    'apt-get install open-iscsi'"
        print
        sys.exit(1)


def mpath_chk():
    try:
        subprocess.check_output(["multipath", "-v0", ])
    except OSError as e:
        print 
        print "multipath not available."
        print "Please install :"
        print "      RH/CentOS: 'yum install device-mapper-multipath'"
        print "      Ubuntu:    'apt-get install multipath-tools'"
        print
        sys.exit(1)


def lsscsi_chk():
    try:
        subprocess.check_output(["lsscsi", "-t", ])
    except OSError as e:
        print 
        print "lsscsi not available."
        print "Please install :"
        print "      RH/CentOS: 'yum install lsscsi'"
        print "      Ubuntu:    'apt-get install lsscsi'"
        print
        sys.exit(1)


def dbck():
    # Check for docker bug: https://github.com/docker/docker/issues/7101"
    try:
        subprocess.check_output(
            "grep sysfs /proc/mounts | grep ro", shell=True)
        try:
            subprocess.call("mount -o rw,remount sysfs /sys")
            sys.exit(0)
        except Exception as e:
            print "Encountered https://github.com/docker/docker/issues/7101"
            print "and cannot remount /sys.  Need to be root?"
            sys.exit(1)
    except Exception as e:
        # sysfs is not mounted 'ro'
        pass

def op_state_poller(instance):
    count = 0
    while count < 10:
       if instance['op_state'] != 'available':
          time.sleep(1)
          count = count + 1
       if count > 9:
          print instance['name'] + " did not become available in 10s"
          sys.exit(-1)
       break

def main():

    if (len(sys.argv) < 2):
        usage()

    dbck()
    iscsiadm_chk()
    mpath_chk()
    lsscsi_chk()
    parser = argparse.ArgumentParser(description='dhutil')
    parser.add_argument('--basename', action="store", dest="basename")
    parser.add_argument('--template', action="store", dest="template")
    parser.add_argument('--createfio', action="store_true")
    parser.add_argument('--size', action="store", dest="size")
    parser.add_argument('--count', action="store", dest='count', type=int)
    parser.add_argument('--numreplicas', action="store", dest='numreplicas',
                        type=int)
    parser.add_argument('--cleanall', action="store_true")
    parser.add_argument('--showall', action="store_true")
    parser.add_argument('--mkfs', action="store_true")
    parser.add_argument('--mpmap', action="store_true")
    parser.add_argument('--dirprefix', action="store", dest='dirprefix')
    parser.add_argument('--chown', action="store", dest='chown')
    parser.add_argument('--fstype', action="store", dest='fstype')
    parser.add_argument('--snappol', action="store", dest="snappol", nargs=2, 
                       metavar=('RETCOUNT','INTERVAL'),help='volume-level snapshot retention count and interval')
    parser.add_argument('--volperf', action="store", dest="volperf", nargs=2, 
                       metavar=('TOTAL_IOPS_MAX','TOTAL_BANDWIDTH_MAX[KBps]'), type=int, 
                       help='volume-level iops and bandwidth policies')
    parser.add_argument('--clone', action="store_true",
                       help='clones app instances that start with basename')
    parser.add_argument('--tenant', action="store",
                       help='creates tenant with given name. If exists, uses that tenant')
    args = parser.parse_args()

    creds = os.getenv("DTSCREDS")
    if not creds or creds == "":
        nocreds()
    user, password, ipaddr = creds.split(":")

    basename = args.basename

    if basename and len(basename) < 3:
        print "Validation Error:  %s : must be at least 3 chars" % basename
        sys.exit(-1)

    # Make sure args make sense
    chk_args(args)

    try:
        print "Connecting to : ", ipaddr
        api = DateraApi(username=user, password=password, hostname=ipaddr)
        # check sw verstion, and if it is 2.1, import the 2.1 API
        if api.system.get()['sw_version'].startswith(API_VER):
           if args.tenant:
              api = DateraApi21(username=user, password=password, hostname=ipaddr, tenant="/root/" + args.tenant)
           else:
              api = DateraApi21(username=user, password=password, hostname=ipaddr, tenant=None)
    except Exception as e:
        PrintException()
        sys.exit(1)

    host = os.uname()[1].split('.')[0]
    tenant = ''

    if args.cleanall:
        unmount(basename)
        target_logout_and_node_cleanup(api, host, basename)
        clean_all(api, basename, args)
        sys.exit(0)

    if args.showall:
        show_all(api)
        if args.mpmap:
            mpmap(api, args, tenant)
        sys.exit(0)

    if args.mpmap and not args.count:
        mpmap(api, args, tenant)
        sys.exit(0)

    cmd = "grep '^InitiatorName' /etc/iscsi/initiatorname.iscsi"
    cmd = cmd + " | sed -e 's/InitiatorName=//'"
    iscsi_initiator = os.popen(cmd).read().strip()
    ii = initiator_create(api, host, iscsi_initiator)

    #
    # Semantics:  If a template exists, create args.count instances
    #             from that template.
    #             If a template does not exist, create args.count instances
    #             Assumes 1:1:1 ratio of AppInstance:StorageInstance:Volume
    # TODO:       Allow non-singleton configurations

    # Make sure template exists
    if args.template:
        if chktempl(api, args.template):
            # If API version > API_VER
            if api.system.get()['sw_version'].startswith(API_VER):
                if args.tenant:
                   for subtenant in api.tenants.list()[0]['subtenants']:
                       if subtenant.endswith(args.tenant):
                           print "Using prexisting subtenant " + args.tenant
                           tenant = "/root/" + args.tenant
                   if tenant == '':
                       api.tenants.create(name=args.tenant)
                       print "Created subtenant: ", args.tenant
                       tenant = "/root/" + args.tenant
                # Create N app_instances from the template
                for n in range(1, args.count + 1):
                   appname = "%s-%d" % (args.basename, n)
                   tname = "/app_templates/" + args.template
                   print "I got here"
                   ai = api.app_instances.create(name=appname, app_template=tname, tenant=tenant)
                   print "I got here too"
                   print "Created app_instance: ", ai['name']
                   for si in ai.storage_instances.list(tenant=tenant):
                      si.acl_policy.initiators.add(ii,tenant=tenant)
                # Login to the storage
                # get app instance status
                for ai in api.app_instances.list(tenant=tenant):
                   if args.basename in ai['name']:
                      for si in ai.storage_instances.list(tenant=tenant):
                         op_state_poller(si)
                         print si['name'] + " is online"
                         target_login(host, si, iscsi_initiator, sleep=0)
                run_cmd("lsscsi -t")
            else:
               for n in range(1, args.count + 1):
                   appname = "%s-%d" % (args.basename, n)
                   tname = "/app_templates/" + args.template
                   ai = api.app_instances.create(name=appname, app_template=tname)
                   print "Created app_instance: ", ai['name']
                   for si in ai.storage_instances.list():
                      si.acl_policy.initiators.add(ii)
               # Login to the storage
               # get app instance status
               for ai in api.app_instances.list():
                  if args.basename in ai['name']:
                     for si in ai.storage_instances.list():
                        op_state_poller(si)
                        print si['name'] + " is online"
                        target_login(host, si, iscsi_initiator, sleep=0)
               run_cmd("lsscsi -t")
        else:
            print args.template, " : does not exist!"
            sys.exit(-1)
    elif args.count:
        #
        # Create N app_instances, storage_instance, and add initiator
        #
        if api.system.get()['sw_version'].startswith(API_VER):
           #
           # Create N app_instances, storage_instance, and add initiator
           #
           if args.tenant:
              for subtenant in api.tenants.list()[0]['subtenants']:
                  if subtenant.endswith(args.tenant):
                      print "Using prexisting subtenant " + args.tenant
                      tenant = "/root/" + args.tenant
              if tenant == '':
                  api.tenants.create(name=args.tenant)
                  print "Created subtenant: ", args.tenant
                  tenant = "/root/" + args.tenant
           for i in range(1, args.count + 1):
              bname = "{}_{}".format(basename, i)
              ai = api.app_instances.create(name=bname, tenant=tenant)
              si = ai.storage_instances.create(name=bname, tenant=tenant)
              si.acl_policy.initiators.add(ii, tenant=tenant)
              volname = "{}_vol".format(bname)
              uuid = vol_create(si, volname, args, api)
              print "Created Volume: %s (%s)" % (volname, uuid)
           for ai in api.app_instances.list(tenant=tenant):
              if basename in ai['name']:
                 # Wait until storage instance is online
                 for si in ai.storage_instances.list(tenant=tenant):
                    op_state_poller(si)
                    print si['name'] + " is online"
                    target_login(host, si, iscsi_initiator, sleep=0)
        else:
           for i in range(1, args.count + 1):
              bname = "{}_{}".format(basename, i)
              ai = api.app_instances.create(name=bname)
              si = ai.storage_instances.create(name=bname)
              si.acl_policy.initiators.add(ii)
              volname = "{}_vol".format(bname)
              uuid = vol_create(si, volname, args, api)
              print "Created Volume: %s (%s)" % (volname, uuid)

           for ai in api.app_instances.list():
              if basename in ai['name']:
                 # Wait until storage instance is online
                 for si in ai.storage_instances.list():
                    op_state_poller(si)
                    print si['name'] + " is online"
                    target_login(host, si, iscsi_initiator, sleep=0)


        run_cmd("lsscsi -t")

    if args.createfio:
        create_fio_files(api,args,tenant)
    
    if args.clone:
        cmd="mount |grep " + args.basename
        global CLONE_AI_LIST 
        CLONE_AI_LIST = clone_an_app_instance(api,args)
        
        #discover cloned volumes and login
        for ai in api.app_instances.list():
            if ai['name'].startswith(args.basename) and ai["name"].endswith("clone"):
                si = ai.storage_instances.list()[0]
                target_login(host, si, iscsi_initiator, sleep=0)

        run_cmd("lsscsi -t")
        mntmap = mpmap(api, args,tenant)
        
        try:
           output = subprocess.check_output(cmd, shell=True)
           if args.basename in output:
              for item in mntmap:
                 if "xfs" in output:
                    cmd = "mkdir -p /{}; mount -o nouuid {} /{}".format(item[1],item[0],item[1])
                 else:
                    cmd = "mkdir -p /{}; mount {} /{}".format(item[1],item[0],item[1])
                 print "mounting " + item[1]
                 os.system(cmd)
                 if item[2].chown:
                    os.system("chown -R {} /{}".format(item[2].chown, item[1]))
        except subprocess.CalledProcessError as e:
           print str(e) + "\n" + basename + " are block devices without filesystems. Cannot mount clone."
           pass

    if args.mkfs:
        mntmap = mpmap(api, args, tenant)
        pool = mp.Pool()
        list(pool.imap_unordered(mkfs, mntmap))
        
if __name__ == '__main__':
    main()
